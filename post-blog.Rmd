---
title: "Markowitz - O problema da média variância"
author: "Neuremberg"
date: "16 de dezembro de 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Usando o R

Para ilustrar a discussão teórica feita até aqui, vamos usar o R para calcular uma fronteira eficiente para um conjunto de ativos.

###  Obtendo e processando dados

Inicialmente vamos carregar o pacote necessários:

```{r ambiente, eval=FALSE}

library(ggplot2)
library(magrittr)
library(quantmod)
library(xts)
library(tseries)

```

Caso não possua esses pacotes instalados você pode usar `install.packages('nome_pacote')` para instalá-los e depois carregue eles usando os comandos acima.

Usaremos o pacote `quantmod` e `xts` para obter os dados de interesse e tratar-los para o objetivo que desejamos. Assim, para o exercício, vamos obter o dados para as seguintes ativos:

* ITSA4 - Itaú SA Investimentos;
* VVAR3 - Via Varejo SA, controladora das empresas Casas Bahias e Ponto Frio;
* FNOR11 - Fundos de Investimento do Nordeste;
* PETR4 - Petrobras;
* BOVV11 - Índice Bovespa.

Usaremos as funções do pacote `quantmod` para obter os preços diárias das ações entre outubro de 2016 e dezembro de 2019. Antes desse período, os dados do índice Bovespa apresenta muitos valores perdidos.

```{r download_ativos, eval=FALSE}

# Definindo parâmetros
simbolos <- c("ITSA4.SA", "VVAR3.SA", "FNOR11.SA", "PETR4.SA", "BOVV11.SA")

startdate <-  '2016-10-27' # Sys.Date() - 730
enddate <- '2019-12-15' # Sys.Date()

# Fazendo download
ativos <- new.env()

getSymbols(Symbols = simbolos, env = ativos, src = 'yahoo',
           from = startdate, to = enddate, auto.assign = TRUE)
ativos <- as.list(ativos)

```

Se tudo tiver corrido corretamente os dados das ações foram baixados em carregados no *environment* `ativos` que posteriormente foi transformando em uma lista. Agora que temos os dados, vamos realizar um processamento de modo a obter o retorno mensais dessas séries, mas antes disso vamos que criar algumas funções para nos auxiliar nisso:


```{r funcoes, eval=TRUE}

get_preco_fechamento <- function(x){
  ## Obtem preço de fechamento
  
  x[, base::grepl(pattern = '\\.Close$', x = dimnames(x)[[2]])]
}

list_to_xts <- function(list_xts){
  ## Transforma uma lista de objetos xts em um objeto xts
  
  nomes <- names(list_xts)
  res <- do.call(cbind.xts, list_xts)
  dimnames(res)[[2]] <- nomes
  
  return(res)
}


```

Na lista `ativos` estão os preços de cada ativos. Em cada objeto `xts` estão guardados informações como o menor preço alçando pela ação no dia, o maior preço alcançado, o preço do ativo na abertura do pregão, o preço de fechamento e outras informação. Para nosso exercício usaremos o preço de fechamento de ativo calcularemos o retorno mensal dos ativos.

```{r retorno_mensal, eval=FALSE}

#Obtendo apenas os preços de fechamento
ativos <- lapply(X = ativos, FUN = get_preco_fechamento)

# calculando retornos mensais
retornos_men <- lapply(ativos, quantmod::monthlyReturn)

# Juntando ativos em um objeto xts
carteira <- list_to_xts(retornos_men)

# Transformando objeto xts em uma matriz e retirando dados perdidos
carteira <-  as.matrix(carteira)
carteira <- na.omit(carteira)

```

Assim, obtemos os retornos mensais dos cinco ativos. Dessa forma, a matriz `carteira` representa a carteira contendo esses ativos. Agora, vamos estimar o retorno esperado de cada ativo, para tanto, será usado o retorno mensal médio como estimativa do retorno esperado.


```{r carrega_data, eval= TRUE, echo=FALSE, message=FALSE}

library(ggplot2)
library(magrittr)
library(quantmod)
library(xts)
library(tseries)


dados <- read.csv2('dados/retornos-mensais.csv')

carteira  <- dados[,-1]
carteira <- as.matrix(carteira)
carteira <- na.omit(carteira)

rm(dados)
```



```{r retorno_esperado}
# Estimando retorno esperados
retornos_esperados <- apply(carteira, MARGIN = 2, mean)
retornos_esperados

```

### Calculando fronteira eficiente

O pacote `tseries` possui uma função chamada `portfolio.optim()`. Dado um conjunto de ativos e um retorno esperado para a carteira, ela calcula a carteira de menor variância. Vamos usar essa função para calcular a fronteira eficiente para o 5 ativos escolhidos.

Para facilitar esse trabalho vamos criar algumas funções:

```{r funcoes_fronteira}

carteira_otima <- function(ativos, retorno_esperado, shorts = FALSE){
  ## Calcula carteira ótima
  
  s <- tseries::portfolio.optim(
    x = ativos,
    pm = retorno_esperado,
    shorts = shorts
  )
  
  res <- list(
    pesos = s[['pw']],
    retorno = s[['pm']],
    risco = s[['ps']]
  )
  
  return(res)
}

get_retorno <- function(res){
  ## Obtém o retorno da carteira ótima
  
  sapply(res, `[[`, i = 'retorno')
}

get_risco <- function(res){
  ## Obtém o risco da carteira ótima
  
  sapply(res, `[[`, i = 'risco')
}

```

Vamos cacular o retorno esperados para o ativos e seus respectivos riscos e guardar tais informações em um `data.frame`. Após isso, vamos gerar um vetor de retornos desejados para as carteira ótimas a fim de gerar a fronteira eficiente.


```{r dados_ativos}

retornos_esperados <- apply(carteira, MARGIN = 2, mean)
riscos <- apply(carteira, MARGIN = 2, sd)

ativos <- data.frame(
  acao = names(retornos_esperados),
  risco = riscos,
  retorno = retornos_esperados,
  row.names = NULL
)

ativos

retorno_min <- 0.5*min(retornos_esperados)
retorno_max <- 1.5*max(retornos_esperados)

retornos_seq <- seq(retorno_min, retorno_max, length.out = 50)

retornos_seq

```

Agora vamos gerar a fronteira eficiente de carteiras

```{r fronteira}

fronteira <- lapply(
  X = retornos_seq,
  FUN = carteira_otima,
  ativos = carteira,
  shorts = TRUE
)

dados_plot <- data.frame(
  retorno = get_retorno(fronteira),
  risco = get_risco(fronteira)
)

dados_plot %>% 
  ggplot(aes(x = retorno, y = risco, color = '#E7B800'))+
  geom_point()+
  geom_line(size = 1)+
  geom_point(data = ativos, aes(x = retorno, y = risco, color = acao))+
  geom_text(data = ativos, aes(x = retorno, y = risco, label = acao, color = acao))+
  coord_flip()+
  labs(
    x = 'Retorno',
    y = 'Risco',
    title = 'Fronteira Eficiente',
    color = ''
  )+
  theme(legend.position = 'none')


```

